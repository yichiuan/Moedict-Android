// automatically generated by the FlatBuffers compiler, do not modify

package moe.taiwan;

import java.nio.*;
import java.lang.*;
import java.util.*;
import com.google.flatbuffers.*;

@SuppressWarnings("unused")
public final class Word extends Table {
  public static Word getRootAsWord(ByteBuffer _bb) { return getRootAsWord(_bb, new Word()); }
  public static Word getRootAsWord(ByteBuffer _bb, Word obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { bb_pos = _i; bb = _bb; }
  public Word __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public String index() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer indexAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public int title(int j) { int o = __offset(6); return o != 0 ? bb.getShort(__vector(o) + j * 2) & 0xFFFF : 0; }
  public int titleLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }
  public ByteBuffer titleAsByteBuffer() { return __vector_as_bytebuffer(6, 2); }
  public int nonRadicalStrokeCount() { int o = __offset(8); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  public int strokeCount() { int o = __offset(10); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  public String radical() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer radicalAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public Heteronym heteronyms(int j) { return heteronyms(new Heteronym(), j); }
  public Heteronym heteronyms(Heteronym obj, int j) { int o = __offset(14); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int heteronymsLength() { int o = __offset(14); return o != 0 ? __vector_len(o) : 0; }

  public static int createWord(FlatBufferBuilder builder,
      int indexOffset,
      int titleOffset,
      int non_radical_stroke_count,
      int stroke_count,
      int radicalOffset,
      int heteronymsOffset) {
    builder.startObject(6);
    Word.addHeteronyms(builder, heteronymsOffset);
    Word.addRadical(builder, radicalOffset);
    Word.addTitle(builder, titleOffset);
    Word.addIndex(builder, indexOffset);
    Word.addStrokeCount(builder, stroke_count);
    Word.addNonRadicalStrokeCount(builder, non_radical_stroke_count);
    return Word.endWord(builder);
  }

  public static void startWord(FlatBufferBuilder builder) { builder.startObject(6); }
  public static void addIndex(FlatBufferBuilder builder, int indexOffset) { builder.addOffset(0, indexOffset, 0); }
  public static void addTitle(FlatBufferBuilder builder, int titleOffset) { builder.addOffset(1, titleOffset, 0); }
  public static int createTitleVector(FlatBufferBuilder builder, short[] data) { builder.startVector(2, data.length, 2); for (int i = data.length - 1; i >= 0; i--) builder.addShort(data[i]); return builder.endVector(); }
  public static void startTitleVector(FlatBufferBuilder builder, int numElems) { builder.startVector(2, numElems, 2); }
  public static void addNonRadicalStrokeCount(FlatBufferBuilder builder, int nonRadicalStrokeCount) { builder.addByte(2, (byte)nonRadicalStrokeCount, (byte)0); }
  public static void addStrokeCount(FlatBufferBuilder builder, int strokeCount) { builder.addByte(3, (byte)strokeCount, (byte)0); }
  public static void addRadical(FlatBufferBuilder builder, int radicalOffset) { builder.addOffset(4, radicalOffset, 0); }
  public static void addHeteronyms(FlatBufferBuilder builder, int heteronymsOffset) { builder.addOffset(5, heteronymsOffset, 0); }
  public static int createHeteronymsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startHeteronymsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static int endWord(FlatBufferBuilder builder) {
    int o = builder.endObject();
    builder.required(o, 4);  // index
    builder.required(o, 6);  // title
    return o;
  }

  @Override
  protected int keysCompare(Integer o1, Integer o2, ByteBuffer _bb) { return compareStrings(__offset(4, o1, _bb), __offset(4, o2, _bb), _bb); }

  public static Word __lookup_by_key(int vectorLocation, String key, ByteBuffer bb) {
    byte[] byteKey = key.getBytes(Table.UTF8_CHARSET.get());
    int span = bb.getInt(vectorLocation - 4);
    int start = 0;
    while (span != 0) {
      int middle = span / 2;
      int tableOffset = __indirect(vectorLocation + 4 * (start + middle), bb);
      int comp = compareStrings(__offset(4, bb.array().length - tableOffset, bb), byteKey, bb);
      if (comp > 0) {
        span = middle;
      } else if (comp < 0) {
        middle++;
        start += middle;
        span -= middle;
      } else {
        return new Word().__assign(tableOffset, bb);
      }
    }
    return null;
  }
}

