// automatically generated by the FlatBuffers compiler, do not modify

package moe;

import java.nio.*;
import java.lang.*;
import java.util.*;
import com.google.flatbuffers.*;

@SuppressWarnings("unused")
public final class Index extends Table {
  public static Index getRootAsIndex(ByteBuffer _bb) { return getRootAsIndex(_bb, new Index()); }
  public static Index getRootAsIndex(ByteBuffer _bb, Index obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { bb_pos = _i; bb = _bb; }
  public Index __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public String words(int j) { int o = __offset(4); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int wordsLength() { int o = __offset(4); return o != 0 ? __vector_len(o) : 0; }

  public static int createIndex(FlatBufferBuilder builder,
      int wordsOffset) {
    builder.startObject(1);
    Index.addWords(builder, wordsOffset);
    return Index.endIndex(builder);
  }

  public static void startIndex(FlatBufferBuilder builder) { builder.startObject(1); }
  public static void addWords(FlatBufferBuilder builder, int wordsOffset) { builder.addOffset(0, wordsOffset, 0); }
  public static int createWordsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startWordsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static int endIndex(FlatBufferBuilder builder) {
    int o = builder.endObject();
    return o;
  }
  public static void finishIndexBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset); }

  private static final int SIZEOF_INT = 4;
  private static final int INITIAL_ARRAY_SIZE = 64;
  ArrayList<Integer> result = new ArrayList<>(INITIAL_ARRAY_SIZE);

  public ArrayList<Integer> search(String pattern) {
    result.clear();

    int o = __offset(4);
    if (o == 0) return result;

    int length = __vector_len(o);
    int vector_start = __vector(o);


    byte[] byteKey = pattern.getBytes(Table.UTF8_CHARSET.get());

    for (int i = 0; i < length; ++i) {
      if (contains(vector_start + (i << 2), byteKey)) {
        result.add(i);
      }
    }

    return result;
  }

  boolean contains(int offset_1, byte[] key) {
    offset_1 += bb.getInt(offset_1);
    int length = bb.getInt(offset_1);

    if (key.length > length) return false;

    int startPos_1 = offset_1 + SIZEOF_INT;

    byte[] bbArray = bb.array();

    for (int i = 0; i < length; i++) {

      if ((length - i) < key.length) return false;

      boolean match = true;
      for (int j = 0; j < key.length; j++) {
        if (bbArray[i + startPos_1 + j] != key[j]) {
          match = false;
          break;
        }
      }
      if (match) return true;
    }
    return false;
  }
}

